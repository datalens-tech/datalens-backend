version: '3'

vars:
  VM_HOST: dl-vm
  VENV_PATH: '{{ if .VENV_PATH }}{{ .VENV_PATH }}{{ else }}{{ .DEFAULT_VENV_PATH }}{{ end }}'

tasks:
  help:
    desc: Show help
    silent: true
    cmds:
      - echo 'Taskfile namespace used for development.'
      - echo 'General:'
      - echo '`task dev:init` to initialize the environment'
      - echo '`task dev:clean` to clean the environment'
      - echo ''
      - echo 'Linting:'
      - echo '`task dev:lint` to lint the code in current directory'
      - echo '`task dev:lint-fix` to fix linting issues the code in current directory'
      - echo ''
      - echo 'Testing:'
      - echo '`task dev:test` to run tests in current directory'
      - echo '`task dev:test -- -k test_name` to run tests with specific name pattern'
      - echo '`task dev:test -- path/to/tests` to run tests in specific directory'
      - echo '`LOG_LEVEL=DEBUG task dev:test` to run tests with specific logging level'
      - echo '`task dev:remote-test` if compose is started remotely'
      - echo ''
      - echo 'Docker-compose:'
      - echo '`task dev:compose-start` to start docker-compose'
      - echo '`task dev:compose-stop` to stop docker-compose'
      - echo '`task dev:compose-stop-all` to stop all running docker containers'
      - echo '`task dev:compose-logs` to show docker-compose logs'
      - echo 'All `dev:compose-*` tasks could be used with DOCKER_HOST, f.e. `DOCKER_HOST=ssh://{{.VM_HOST}} task dev:compose-start`'
      - echo 'Alternatively, use `task dev:compose-remote-*` assuming that `{{.VM_HOST}}` alias is set'
      - echo ''
      - echo 'If compose is started remotely via SSH, use `task dev:ssh-forward-start` to forward ports to localhost'
      - echo 'Use `task dev:ssh-forward-stop` to stop all SSH port forwarding'
      - echo ''
      - echo 'Development workflow example:'
      - echo '0. source environment variables'
      - echo '1. `cd %PACKAGE_DIR%`'
      - echo '2. `task dev:init`'
      - echo '3. `task dev:compose-remote-start`'
      - echo '4. `task dev:ssh-forward-start`'
      - echo '5. Write some code'
      - echo '6. `task dev:lint-fix`'
      - echo '7. `task dev:test-remote`'
      - echo '8. Repeat 5-7'
      - echo '9. `task dev:ssh-forward-stop`'
      - echo '10. `task dev:compose-remote-stop`'

  init:
    desc: Initialize environment
    cmds:
      - echo "Cleaning unused envs in {{.VENV_PATH}}"
      - for env in "$UNUSED_ENVS"; do
          echo "Removing $env";
          poetry env remove $env --directory={{.PYPROJECT_TOML_PATH}};
        done;
      - echo "Initializing python virtual environment in {{.VENV_PATH}}"
      - poetry install --directory={{.PYPROJECT_TOML_PATH}} --sync --no-root --with mypy
    requires:
      vars:
        - PYPROJECT_TOML_PATH
    vars:
      UNUSED_ENVS:
        sh: poetry env list --no-ansi --directory={{.PYPROJECT_TOML_PATH}}
          | sed 's/ (Activated)//g'
          | grep -v \".venv\" || true

  poetry-lock:
    desc: Lock dependencies in metapkg
    vars:
      POETRY_VERSION:
        sh: cat .poetry-version
    cmds:
      - poetry self update {{.POETRY_VERSION}}
      - poetry lock --no-update --directory={{.METAPKG_DIR}}
    requires:
      vars:
        - METAPKG_DIR

  venv-bin:
    desc: Run venv bin
    dir: '{{ if .DIR }}{{ .DIR }}{{ else }}{{ .USER_WORKING_DIR }}{{ end }}'
    cmds:
      - 'PATH="{{.VENV_PATH}}/bin:$PATH" {{if ne .ENVS ""}} {{.ENVS}}{{end}} {{.VENV_PATH}}/bin/{{.CLI_ARGS}}'
    requires:
      vars:
        - VENV_PATH

  _run-for-each-lib:
    desc: Run command for each library
    cmds:
      - |
        exit_code=0;
        command_status=0;
        for LIB_PATH in $LIB_PATHS; do
          ITERATION_COMMAND=${COMMAND//%s/$LIB_PATH};
          echo "Going to run '$ITERATION_COMMAND'";
          set +e;
          eval $ITERATION_COMMAND || command_status=$?;
          set -e;
          if [ $command_status -ne 0 ]; then
            echo "Command failed with exit status $command_status";
            exit_code=$command_status;
          fi;
          if [ $FAIL_FAST == "true" ] && [ $exit_code -ne 0 ]; then
            echo "FAIL_FAST is true and command failed, breaking";
            break;
          fi
        done;
        exit $exit_code;
    env:
      FAIL_FAST: '{{.FAIL_FAST | default "true"}}'
      COMMAND: '{{.COMMAND}}'
      LIB_PATHS:
        sh: |
          find "{{.USER_WORKING_DIR}}" -name 'pyproject.toml' \
            | sort \
            | xargs -n1 realpath \
            | xargs -n1 dirname \
            {{ if .EXCLUDE_LIB_PATHS -}}
              {{- range $i, $path := .EXCLUDE_LIB_PATHS | splitLines -}}
                {{- if ne $path "" }} | grep -v "^{{$path}}$" {{ end -}}
              {{- end -}}
            {{- end -}}

  poetry:
    desc: Run poetry command
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - poetry --directory={{.PYPROJECT_TOML_PATH}} {{.CLI_ARGS}}

  venv-python:
    desc: Run poetry command
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: venv-bin
        vars:
          DIR: "{{.DIR}}"
          CLI_ARGS: "python -m {{.CLI_ARGS}}"

  clean:
    desc: Clean environment
    cmds:
      - echo "Cleaning python virtual environment"
      - rm -rf {{.VENV_PATH}}
    requires:
      vars:
        - VENV_PATH

  toml-sort:
    desc: Sort toml files
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - echo "Running toml-sort checks..."
      - task: venv-bin
        vars:
          DIR: "{{.PROJECT_ROOT_PATH}}"
          CLI_ARGS: 'toml-sort {{if eq .FIX "true"}}--in-place{{else}}--check{{end}} {{.TOML_FILES}}'
    vars:
      FIX: '{{.FIX | default "true"}}'
      TOML_FILES:
        sh: |
          find {{.CLI_ARGS | default "."}} -name 'pyproject.toml' \
          | sort \
          | xargs -n1 realpath \
          {{ if .EXCLUDE_TOML_SORT -}}
            {{- range $i, $path := .EXCLUDE_TOML_SORT | splitLines -}}
              {{- if ne $path "" }} | grep -v "^{{$path}}$" {{ end -}}
            {{- end -}}
          {{- end -}}
          | tr '\n' ' '

  _deptry:
    desc: Run deptry on package
    requires:
      vars:
        - LIB_PATH
    cmds:
      - echo "Running deptry checks for {{.LIB_PATH}}"
      - task: venv-python
        vars:
          DIR: "{{.LIB_PATH}}"
          CLI_ARGS: |
            deptry . \
              --exclude ".*tests"

  _deptry-tests-dependencies:
    desc: Run deptry on tests dependencies
    requires:
      vars:
        - LIB_PATH
    cmds:
      - echo "Running deptry checks for testing dependencies for {{.LIB_PATH}}"
      - |
        if grep -q '\[tool\.poetry\.group\.tests\.dependencies\]' {{.LIB_PATH}}/pyproject.toml; then
          sed -i.backup '/^\[tool\.poetry\.group\.tests\.dependencies\]/d' {{.LIB_PATH}}/pyproject.toml
        else
          echo "No tests dependencies found in {{.LIB_PATH}}/pyproject.toml";
        fi
      - defer: |
          if [ -f {{.LIB_PATH}}/pyproject.toml.backup ]; then
            mv {{.LIB_PATH}}/pyproject.toml.backup {{.LIB_PATH}}/pyproject.toml
          fi
      - task: venv-python
        vars:
          DIR: "{{.LIB_PATH}}"
          CLI_ARGS: |
            deptry .

  deptry:
    desc: Run deptry
    cmds:
      - task: _run-for-each-lib
        vars:
          COMMAND: 'task dev:_deptry LIB_PATH=%s'
      - task: _run-for-each-lib
        vars:
          COMMAND: 'task dev:_deptry-tests-dependencies LIB_PATH=%s'

  _mypy:
    desc: Run mypy on package
    requires:
      vars:
        - LIB_PATH
    cmds:
      - echo "Running mypy checks for {{.LIB_PATH}}"
      - task: venv-python
        vars:
          DIR: "{{.LIB_PATH}}"
          CLI_ARGS: |
            mypy .

  mypy:
    desc: Run mypy
    cmds:
      - task: _run-for-each-lib
        vars:
          COMMAND: 'task dev:_mypy LIB_PATH=%s'

  lint:
    desc: Lint code
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - echo "Running black checks..."
      - task: venv-python
        vars:
          CLI_ARGS: "black --config {{.LINTERS_PYPROJECT_TOML_PATH}} --check {{.LINT_PATH}}"

      - echo "Running isort checks..."
      - task: venv-python
        vars:
          CLI_ARGS: "isort --settings-path {{.LINTERS_PYPROJECT_TOML_PATH}} --check-only {{.LINT_PATH}}"

      - echo "Running ruff checks..."
      - task: venv-python
        vars:
          CLI_ARGS: "ruff check {{.LINT_PATH}}"

      - task: toml-sort
        vars:
          FIX: 'false'

      - task: deptry

      - task: mypy
    vars:
      LINT_PATH: '{{.CLI_ARGS | default "."}}'

  lint-fix:
    desc: Lint fix code
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - echo "Running black fixes..."
      - task: venv-python
        vars:
          CLI_ARGS: "black --safe --config {{.LINTERS_PYPROJECT_TOML_PATH}} {{.LINT_PATH}}"

      - echo "Running isort fixes..."
      - task: venv-python
        vars:
          CLI_ARGS: "isort --settings-path {{.LINTERS_PYPROJECT_TOML_PATH}} {{.LINT_PATH}}"

      - echo "Running ruff fixes..."
      - task: venv-python
        vars:
          CLI_ARGS: "ruff check --fix {{.LINT_PATH}}"

      - task: toml-sort
        vars:
          FIX: 'true'

      - task: deptry

      - task: mypy
    vars:
      LINT_PATH: '{{.CLI_ARGS | default "."}}'

  test:
    desc: Run tests
    cmds:
      - task: venv-bin
        vars:
          CLI_ARGS: |
            pytest {{.CLI_ARGS}} \
            {{ if .LOG_LEVEL }}--log-cli-level={{.LOG_LEVEL}}{{ end }}
          ENVS: '{{.ENVS | default ""}}'
    vars:
      LOG_LEVEL: '{{.LOG_LEVEL | default ""}}'
      CLI_ARGS: '{{.CLI_ARGS | default "."}}'

  test-remote:
    desc: Run tests with remote docker-compose
    cmds:
      - task: test
        vars:
          ENVS: "DOCKER_HOST=ssh://{{.VM_HOST}}"

  _compose:
    dir: "{{.USER_WORKING_DIR}}"
    requires:
      vars:
        - CLI_ARGS
    cmds:
      - |
        {{ if .DOCKER_HOST }}DOCKER_HOST={{.DOCKER_HOST}}{{ end }} \
        docker compose \
        --file {{.DOCKER_COMPOSE_FILE}} \
        {{if ne .DOCKER_COMPOSE_DEV_FILE ""}}--file {{.DOCKER_COMPOSE_DEV_FILE}}{{end}} \
        {{.CLI_ARGS}}
    vars:
      DOCKER_COMPOSE_FILE: '{{.DOCKER_COMPOSE_FILE | default "docker-compose.yml"}}'
      DOCKER_COMPOSE_DEV_FILE:
        sh: find . -type f -name docker-compose-dev.yml
      DOCKER_HOST: '{{.DOCKER_HOST | default ""}}'

  compose-start:
    desc: Start docker-compose
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: _compose
        vars:
          CLI_ARGS: up {{if eq .DETACH "true"}}-d{{end}} --build
          DOCKER_HOST: '{{.DOCKER_HOST | default ""}}'
    vars:
      DETACH: '{{.DETACH | default true }}'

  compose-remote-start:
    desc: Start docker-compose remotely
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: compose-start
        vars:
          DOCKER_HOST: "ssh://{{.VM_HOST}}"

  compose-stop:
    desc: Stop docker-compose
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: _compose
        vars:
          CLI_ARGS: down
          DOCKER_HOST: '{{.DOCKER_HOST | default ""}}'

  compose-remote-stop:
    desc: Stop docker-compose remotely
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: compose-stop
        vars:
          DOCKER_HOST: "ssh://{{.VM_HOST}}"

  compose-clean:
    desc: Stop and remove all docker containers, images and volumes
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: _compose
        vars:
          CLI_ARGS: down --rmi all --volumes --remove-orphans
          DOCKER_HOST: '{{.DOCKER_HOST | default ""}}'

  compose-remote-clean:
    desc: Stop and remove all docker containers, images and volumes remotely
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: compose-clean
        vars:
          DOCKER_HOST: "ssh://{{.VM_HOST}}"

  compose-stop-all:
    desc: Stop all docker containers
    cmds:
      - docker stop $(docker ps -q)

  compose-remote-stop-all:
    desc: Stop all docker containers remotely
    cmds:
      - DOCKER_HOST=ssh://{{.VM_HOST}} docker stop $(DOCKER_HOST=ssh://{{.VM_HOST}} docker ps -q)

  compose-clean-all:
    desc: Stop and remove all docker containers, images and volumes
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - echo "Stopping all docker containers"
      - task: _compose
        vars:
          CLI_ARGS: rm --stop --force --volumes
          DOCKER_HOST: '{{.DOCKER_HOST | default ""}}'
      - echo "Removing all docker containers"
      - |
        {{ if .DOCKER_HOST }}DOCKER_HOST={{.DOCKER_HOST}}{{ end }} \
        docker rm $({{ if .DOCKER_HOST }}DOCKER_HOST={{.DOCKER_HOST}}{{ end }} docker ps --all --quiet) --force || echo "Failed to remove containers"
      - echo "Removing all docker images"
      - |
        {{ if .DOCKER_HOST }}DOCKER_HOST={{.DOCKER_HOST}}{{ end }} \
        docker rmi $({{ if .DOCKER_HOST }}DOCKER_HOST={{.DOCKER_HOST}}{{ end }} docker images --quiet) --force || echo "Failed to remove images"
      - echo "Removing all docker buildx cache"
      - |
        {{ if .DOCKER_HOST }}DOCKER_HOST={{.DOCKER_HOST}}{{ end }} \
        docker buildx prune --all --force || echo "Failed to prune buildx cache"

  compose-remote-clean-all:
    desc: Stop and remove all docker containers, images and volumes remotely
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: compose-clean-all
        vars:
          DOCKER_HOST: "ssh://{{.VM_HOST}}"

  compose-logs:
    desc: Show docker-compose logs
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: _compose
        vars:
          CLI_ARGS: logs --follow {{.CONTAINER}}
          DOCKER_HOST: '{{.DOCKER_HOST | default ""}}'

  compose-remote-logs:
    desc: Show docker-compose logs remotely
    dir: "{{.USER_WORKING_DIR}}"
    cmds:
      - task: compose-logs
        vars:
          DOCKER_HOST: "ssh://{{.VM_HOST}}"
          CONTAINER: '{{.CONTAINER | default ""}}'

  ssh-forward-start:
    desc: Forward docker ports to localhost
    cmds:
      - for port in $PORTS; do
          echo "Forwarding port $port";
          ssh -f -N -L $port:localhost:$port {{.VM_HOST}};
        done;
        wait
    env:
      PORTS:
        sh: DOCKER_HOST=ssh://{{.VM_HOST}} docker ps --format "{{`{{.Ports}}`}}"
          | grep -o '0.0.0.0:[0-9]*->'
          | sed 's/->//g'
          | sed 's/0.0.0.0://g'
          | uniq

  ssh-forward-stop:
    desc: Stop SSH port forwarding for Docker containers
    cmds:
      - echo "Next processes will be killed:"
      - ps -ef | grep "ssh -f -N -L" | grep --invert-match "grep"
      - pkill -f "ssh -f -N -L"

  squash:
    desc: Squash all commits made on CHILD_BRANCH relative to PARENT_BRANCH into single one (using git reset --soft)
    vars:
      REMOTE: '{{.REMOTE | default "origin"}}'
    requires:
      vars:
        - PARENT_BRANCH
        - CHILD_BRANCH
    cmds:
      - git fetch {{.REMOTE}} -f {{.PARENT_BRANCH}}:{{.PARENT_BRANCH}}
      - git switch {{.CHILD_BRANCH}}
      - git fetch {{.REMOTE}} {{.CHILD_BRANCH}}
      - git reset --soft $(git merge-base {{.PARENT_BRANCH}} HEAD)
      - echo 'Now you can commit merged changes with "git commit -m "commit message"'
