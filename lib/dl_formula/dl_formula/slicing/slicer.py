"""
Formula slicing.

A formula (``Formula`` class instance) represents a tree of nodes (instances of ``FormulaItem`` subclasses).
Complex processing of formulas may require them to be split into several parts that will be processed separately
by different parts of the code, in different environments, etc..

``FormulaSlicer`` implements this procedure (slicing) via recursing the formula from the leaves, up to the root
and checking whether the current node still fits the current slice, or has to be moved up to the next one.

``SliceSchema`` defines the sequence of ``LevelBoundary`` subclass instances that do the node checking.
If a formula has exhausted all of its nodes (root has been reached), but there are still more slices to go,
then it is "pulled" through these slices as a field node, at each level representing its content

from __future__ import annotations

from the previous level.

Example:

Say, we want to split ``RANK(SUM([Sales]), MIN([Order Date])) - 1`` and window function level (RANK)
so that the part without window functions can be processed in a database that does not support them,
and the rest somewhere that allows their usage:

```
original:       RANK(SUM([Sales]), MIN([Order Date])) - 1
levels:
    toplevel    RANK(▫▫▫▫▫▫▫▫▫▫▫▫, ▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫) - 1
    window           SUM([Sales])  MIN([Order Date])
```

Here, after slicing we still have one formula at the top level, while the window function arguments have been
cut off as two separate sub-formulas ``SUM([Sales])`` and ``MIN([Order Date])`` at the lower level.
The top-level formula that has the ``RANK`` function call references them as fields with autogenerated names.

``FormulaSlicer`` returns the sliced formula as a ``SlicedFormulaInfo`` object, that stores all the separate parts
of the formula on a per-slice basis with info about the autogenerated fields at each level.
"""

import logging
from typing import (
    Dict,
    Iterable,
    List,
    Optional,
    Set,
    Tuple,
    TypeVar,
)

import attr

from dl_formula.core.index import NodeHierarchyIndex
import dl_formula.core.nodes as nodes
from dl_formula.inspect.expression import enumerate_autonomous_children
from dl_formula.slicing.env import SlicerEnvironment
from dl_formula.slicing.schema import (
    LevelBoundary,
    SliceSchema,
)


LOGGER = logging.getLogger(__name__)


@attr.s
class LevelSlice:
    name: str = attr.ib()
    aliased_nodes: Dict[str, nodes.Formula] = attr.ib(factory=dict)
    required_fields: Set[str] = attr.ib(factory=set)

    def is_lazy(self) -> bool:
        """
        Check whether this slice is lazy
        (every formula consists of a single child  that is a field referencing the previous slice).
        """

        for _alias, node in self.aliased_nodes.items():
            if not isinstance(node.expr, nodes.Field):
                # there's something more going on
                return False

        return True


@attr.s
class SlicedFormulaInfo:
    slices: List[LevelSlice] = attr.ib(factory=list)


_FORMULA_ITEM_TV = TypeVar("_FORMULA_ITEM_TV", bound=nodes.FormulaItem)


@attr.s
class FormulaSlicer:
    slice_schema: SliceSchema = attr.ib(factory=SliceSchema)
    env: SlicerEnvironment = attr.ib(factory=SlicerEnvironment)

    @staticmethod
    def _get_child_expression_nodes(node: nodes.FormulaItem) -> Iterable[nodes.FormulaItem]:
        if isinstance(node, nodes.WindowFuncCall):
            return node.args  # to avoid iterating over grouping node
        return node.children

    def _boundary_for_level(self, level: int) -> LevelBoundary:
        return self.slice_schema.levels[level]

    def _get_node_alias(self, node: nodes.FormulaItem, level: int) -> str:
        level_cache = self.env.cache_sliced_node_name[level]

        # Unwrap Formula objects
        if isinstance(node, nodes.Formula):
            node = node.expr

        alias = level_cache.get(node)
        if alias is None:
            alias = self._boundary_for_level(level).generate_sliced_node_name(node)
            level_cache.add(node, value=alias)

        return alias

    def _slice_node(
        self,
        sliced_formula_info: SlicedFormulaInfo,
        parent_node: _FORMULA_ITEM_TV,
        child_node: nodes.FormulaItem,
        child_node_idx: NodeHierarchyIndex,
        level: int,
    ) -> Tuple[_FORMULA_ITEM_TV, nodes.Field]:
        # generate replacement field
        alias = self._get_node_alias(child_node, level=level)
        replacement_field = nodes.Field.make(
            name=alias,
            meta=nodes.NodeMeta(position=child_node.position),
        )

        # register in result object
        sliced_formula_info.slices[level].aliased_nodes[alias] = nodes.Formula.make(
            expr=child_node,
            meta=nodes.NodeMeta(position=child_node.position),
        )
        if level < len(sliced_formula_info.slices) - 1:
            sliced_formula_info.slices[level + 1].required_fields.add(alias)

        # replace in parent
        parent_node = parent_node.replace_at_index(index=child_node_idx, expr=replacement_field)
        return parent_node, replacement_field

    def _pull_to_level_and_replace(
        self,
        sliced_formula_info: SlicedFormulaInfo,
        parent_node: _FORMULA_ITEM_TV,
        child_node: nodes.FormulaItem,
        child_node_idx: NodeHierarchyIndex,
        parent_stack: Tuple[nodes.FormulaItem, ...],
        from_level: int,
        to_level: int,
    ) -> _FORMULA_ITEM_TV:
        original_child_node = child_node
        while from_level < to_level:
            if self._boundary_for_level(from_level).should_maintain_level(
                node=original_child_node, inspect_env=self.env.inspect_env, parent_stack=parent_stack
            ):
                # expression must stay at current execution level
                # so it must be sliced off and represented as a field on higher levels
                parent_node, child_node = self._slice_node(
                    sliced_formula_info=sliced_formula_info,
                    parent_node=parent_node,
                    child_node=child_node,
                    child_node_idx=child_node_idx,
                    level=from_level,
                )
            from_level += 1

        return parent_node

    def _slice_node_recursively(
        self,
        sliced_formula_info: SlicedFormulaInfo,
        cur_node: nodes.FormulaItem,
        parent_stack: Tuple[nodes.FormulaItem, ...],
    ) -> Tuple[int, nodes.FormulaItem]:
        original_cur_node = cur_node
        parent_stack_for_children = parent_stack + (cur_node,)  # FIXME: replace with stack from enumerate?

        # first calculate the level of children
        children_and_levels: List[Tuple[NodeHierarchyIndex, nodes.FormulaItem, int]] = []
        for child_node_idx, child_node, _ in enumerate_autonomous_children(cur_node, parent_stack=parent_stack):
            child_level, sliced_child_node = self._slice_node_recursively(
                sliced_formula_info=sliced_formula_info,
                cur_node=child_node,
                parent_stack=parent_stack_for_children,
            )
            if sliced_child_node is not child_node:
                cur_node = cur_node.replace_at_index(index=child_node_idx, expr=sliced_child_node)

            children_and_levels.append((child_node_idx, sliced_child_node, child_level))

        cur_level = max(child_level for _, _, child_level in children_and_levels) if children_and_levels else 0

        # now check if we've reached the level boundary
        while self._boundary_for_level(cur_level).should_raise_level(
            node=original_cur_node,
            inspect_env=self.env.inspect_env,
            parent_stack=parent_stack,
        ):
            # current expression must be moved up one level
            cur_level += 1
            # its children will be either sliced off (if they are incompatible with this next level)
            # or also moved up if they are neutral with respect to the level boundary
            # (the result of `boundary.check_level(child)`

        # slice off all the children that belong to one of the previous levels
        sliced_cur_node = cur_node
        for child_node_idx, sliced_child_node, child_level in children_and_levels:
            sliced_cur_node = self._pull_to_level_and_replace(
                sliced_formula_info=sliced_formula_info,
                parent_node=sliced_cur_node,
                child_node=sliced_child_node,
                child_node_idx=child_node_idx,
                parent_stack=parent_stack_for_children,
                from_level=child_level,
                to_level=cur_level,
            )

        return cur_level, sliced_cur_node

    def slice_formula(
        self,
        formula: nodes.Formula,
        alias: Optional[str] = None,
    ) -> SlicedFormulaInfo:
        """
        Slice node expression into parts corresponding to each slice level.
        """

        sliced_formula_info = SlicedFormulaInfo(
            slices=[LevelSlice(name=boundary.name) for boundary in self.slice_schema.levels],
        )

        formula_expr_idx = NodeHierarchyIndex.make(0)
        formula_expr = formula[formula_expr_idx]
        # Just a formality to show and make sure that we have the correct `formula_expr_idx`
        assert formula_expr is formula.expr

        # slice it into parts
        formula_expr_parent_stack = (formula,)
        level_after_slicing, sliced_expr = self._slice_node_recursively(
            sliced_formula_info=sliced_formula_info,
            cur_node=formula_expr,
            parent_stack=formula_expr_parent_stack,
        )
        sliced_formula = formula.replace_at_index(index=formula_expr_idx, expr=sliced_expr)

        # stretch it up as a field to the top level
        sliced_formula = self._pull_to_level_and_replace(
            sliced_formula_info=sliced_formula_info,
            parent_node=sliced_formula,
            child_node=sliced_expr,
            child_node_idx=formula_expr_idx,
            from_level=level_after_slicing,
            parent_stack=formula_expr_parent_stack,
            to_level=self.slice_schema.max_level,
        )

        # register formula in last level under an alias
        level = self.slice_schema.max_level
        alias = alias or self._get_node_alias(sliced_formula, level=level)
        sliced_formula_info.slices[level].aliased_nodes[alias] = sliced_formula
        return sliced_formula_info
