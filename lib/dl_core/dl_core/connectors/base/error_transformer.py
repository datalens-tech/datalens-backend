import abc
import asyncio
import re
from typing import (
    Any,
    Callable,
    ClassVar,
    Iterable,
    Optional,
    Type,
    TypedDict,
)

import attr
from sqlalchemy import exc as sa_exc

import dl_core.exc as exc
from dl_core.exc import DatabaseQueryError


class DBExcKWArgs(TypedDict, total=False):
    db_message: Optional[str]
    query: Optional[str]
    orig: Optional[Exception]
    details: dict[str, Any]


class DbErrorTransformer(abc.ABC):
    _DEFAULT_EXC_CLS: ClassVar[Type[exc.DatabaseQueryError]] = exc.DatabaseQueryError

    def make_bi_error_parameters(
        self,
        wrapper_exc: Exception,
        debug_compiled_query: Optional[str] = None,
    ) -> tuple[Type[exc.DatabaseQueryError], DBExcKWArgs]:
        kw: DBExcKWArgs = DBExcKWArgs(
            db_message=str(wrapper_exc),
            query=debug_compiled_query,
            orig=wrapper_exc,
            details={},
        )

        return self._DEFAULT_EXC_CLS, kw

    def make_bi_error(
        self,
        wrapper_exc: Exception,
        orig_exc: Optional[Exception] = None,
        debug_compiled_query: Optional[str] = None,
    ) -> exc.DatabaseQueryError:
        trans_exc_cls, kw = self.make_bi_error_parameters(
            wrapper_exc=wrapper_exc,
            debug_compiled_query=debug_compiled_query,
        )
        return trans_exc_cls(**kw)


ExcMatchCondition = Callable[[Exception], bool]


@attr.s(frozen=True, kw_only=True)
class ErrorTransformerRule(abc.ABC):
    """Definition of a rule for transforming exceptions raised by a connector
    to their BI-domain exception counterparts. See `ChainedDbErrorTransformer` for more details.

    `when` - is a condition that is evaluated for the exception raised by a connector.
    If a condition is matched then `then_raise` exception will be raised

    `then_raise` - is a BI-domain exception that will be raised if `when` condition is matched
    """

    when: ExcMatchCondition = attr.ib()
    then_raise: Type[exc.DatabaseQueryError] = attr.ib()

    def get_bi_error_class(
        self,
        wrapper_exc: Exception,
    ) -> Optional[Type[exc.DatabaseQueryError]]:
        if self.when(wrapper_exc):
            return self.then_raise
        else:
            return None


def wrapper_exc_is(wrapper_exc_cls: Type[Exception]) -> ExcMatchCondition:
    def _(wrapper_exc: Exception) -> bool:
        return isinstance(wrapper_exc, wrapper_exc_cls)

    return _


def orig_exc_is(orig_exc_cls: Type[Exception]) -> ExcMatchCondition:
    def _(wrapper_exc: Exception) -> bool:
        orig_exc = getattr(wrapper_exc, "orig", None)
        return isinstance(orig_exc, orig_exc_cls)

    return _


def wrapper_exc_is_and_matches_re(wrapper_exc_cls: Type[Exception], err_regex_str: str) -> ExcMatchCondition:
    pattern = re.compile(err_regex_str)

    def _(wrapper_exc: Exception) -> bool:
        return isinstance(wrapper_exc, wrapper_exc_cls) and pattern.search(str(wrapper_exc)) is not None

    return _


@attr.s(frozen=True)
class ChainedDbErrorTransformer(DbErrorTransformer):
    """Transformer for exceptions raised by a connector
    to their BI-domain exception counterparts that works as a part of a chain of rules.
    The rules are applied one-by-one in a chain.
    The first rule in a chain with a matching condition will result in raising
    corresponding BI-domain exception.
    If none of the rules match the condition a fallback exception will be raised.

    `rule_chain` - is a sequence of `ErrorTransformerRule` that are applied one-by-one.
    If a rule condition is matched it produces a BI-domain exception that will be raised.

    `fallback_exc` - is a BI-domain exception that will be raised if none of the rule conditions were matched
    """

    rule_chain: Iterable[ErrorTransformerRule] = attr.ib()
    fallback_exc: Type[exc.DatabaseQueryError] = attr.ib(default=exc.DatabaseQueryError)

    def make_bi_error(
        self,
        wrapper_exc: Exception,
        orig_exc: Optional[Exception] = None,
        debug_compiled_query: Optional[str] = None,
    ) -> DatabaseQueryError:
        transformed_exc_cls: Type[DatabaseQueryError] = self._get_bi_error_cls(wrapper_exc)
        kw: DBExcKWArgs = self._get_error_kw(debug_compiled_query, orig_exc, wrapper_exc)
        return transformed_exc_cls(**kw)

    def make_bi_error_parameters(
        self,
        wrapper_exc: Exception,
        debug_compiled_query: Optional[str] = None,
    ) -> tuple[Type[exc.DatabaseQueryError], DBExcKWArgs]:
        transformed_exc_cls: Type[DatabaseQueryError] = self._get_bi_error_cls(wrapper_exc)
        orig_exc = getattr(wrapper_exc, "orig", None)
        kw: DBExcKWArgs = self._get_error_kw(debug_compiled_query, orig_exc, wrapper_exc)

        return transformed_exc_cls, kw

    def _get_bi_error_cls(
        self,
        wrapper_exc: Exception,
    ) -> Type[exc.DatabaseQueryError]:
        transformed_exc_class_generator = (t.get_bi_error_class(wrapper_exc) for t in self.rule_chain)
        return next(
            (exc_cls for exc_cls in transformed_exc_class_generator if exc_cls is not None),
            DbErrorTransformer._DEFAULT_EXC_CLS,
        )

    @staticmethod
    def _get_error_kw(
        debug_compiled_query: Optional[str], orig_exc: Optional[Exception], wrapper_exc: Exception
    ) -> DBExcKWArgs:
        return dict(
            db_message=str(orig_exc) if orig_exc else str(wrapper_exc),
            query=debug_compiled_query,
            orig=orig_exc,
            details={},
        )


default_error_transformer_rules = (
    ErrorTransformerRule(
        when=orig_exc_is(sa_exc.NoSuchTableError),  # FIXME: not an exc.DatabaseQueryError
        then_raise=exc.SourceDoesNotExist,
    ),
    ErrorTransformerRule(when=wrapper_exc_is(sa_exc.OperationalError), then_raise=exc.DatabaseOperationalError),
    ErrorTransformerRule(when=wrapper_exc_is(asyncio.TimeoutError), then_raise=exc.SourceTimeout),
)


def make_default_transformer_with_custom_rules(*custom_rules: ErrorTransformerRule) -> ChainedDbErrorTransformer:
    return ChainedDbErrorTransformer(custom_rules + default_error_transformer_rules)


def make_rule_from_descr(
    descr: tuple[
        tuple[Type[Exception], Optional[str]],
        Type[exc.DatabaseQueryError],
    ]
) -> ErrorTransformerRule:
    (wrapper_exc, re_pattern), then_raise = descr
    if re_pattern is None:
        return ErrorTransformerRule(when=wrapper_exc_is(wrapper_exc), then_raise=then_raise)
    else:
        return ErrorTransformerRule(when=wrapper_exc_is_and_matches_re(wrapper_exc, re_pattern), then_raise=then_raise)
